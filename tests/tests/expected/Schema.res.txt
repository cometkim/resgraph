generating schema from tests/Schema.res

noticing group
noticing pet
Adding union userOrGroup
noticing user
Adding enum userStatus
Checking for type to attach resolver to
Checking for type to attach resolver to
Checking for type to attach resolver to
Adding input object userConfigContext
Adding input object userConfig
Checking for type to attach resolver to
noticing query
Checking for type to attach resolver to
Checking for type to attach resolver to
Checking for type to attach resolver to
Checking for type to attach resolver to
Checking for type to attach resolver to
noticing mutation
Checking for type to attach resolver to
Adding interface hasName
Checking for type to attach resolver to
Checking for type to attach resolver to
Adding interface node
Checking for type to attach resolver to
Checking for type to attach resolver to
Checking for type to attach resolver to
=== DEBUG SDL ===

directive @sourceLoc(fileUri: String!, startLine: Int!, startCol: Int!, startLine: Int!, startCol: Int!) on FIELD_DEFINITION | OBJECT | ENUM | UNION | INPUT_OBJECT | INPUT_FIELD_DEFINITION | INTERFACE | SCALAR | ARGUMENT_DEFINITION

enum UserStatus {
  Online
  Offline
  Idle
}

union UserOrGroup @sourceLoc(fileUri: "tests/Schema.res", startLine: 20, startCol: 0, endLine: 20, endCol: 96) {
  User
  Group
}

input UserConfig @sourceLoc(fileUri: "tests/Schema.res", startLine: 63, startCol: 0, endLine: 69, endCol: 1) {
  id: String!
  name: String
  context: UserConfigContext
}

input UserConfigContext @sourceLoc(fileUri: "tests/Schema.res", startLine: 57, startCol: 0, endLine: 60, endCol: 1) {
  groupId: String
  name: String
}

interface Node @sourceLoc(fileUri: "./src/NodeInterface.res", startLine: 2, startCol: 0, endLine: 6, endCol: 1) {
  id: ID!
}

interface HasName @sourceLoc(fileUri: "./tests/HasNameInterface.res", startLine: 2, startCol: 0, endLine: 2, endCol: 40) {
  abbreviatedName: String
  name: String!
}

type Mutation @sourceLoc(fileUri: "tests/Schema.res", startLine: 146, startCol: 0, endLine: 146, endCol: 18) {
  addUser(name: String!): User
}

type User implements Node & HasName @sourceLoc(fileUri: "./tests/User.res", startLine: 2, startCol: 0, endLine: 9, endCol: 1) {
  id: ID!
  allNames: [String!]!
  currentStatus: UserStatus!
  name(includeFullName: Boolean): String!
  id: ID!
  name: String!
  age: Int!
  lastAge: Int
  abbreviatedName: String
}

type Group implements Node & HasName @sourceLoc(fileUri: "tests/Schema.res", startLine: 4, startCol: 0, endLine: 9, endCol: 1) {
  id: ID!
  name: String!
  abbreviatedName: String
}

type Query @sourceLoc(fileUri: "./tests/Query.res", startLine: 1, startCol: 0, endLine: 1, endCol: 15) {
  nodes(ids: [ID!]!): [Node]!
  node(id: ID!): Node
  hasName(id: ID!): HasName
  pet: Pet
  listAsArgs(regularList: [String]!, optionalList: [String!], nullableList: [String], nullableInnerList: [String], list1: [String], list2: [[String]], list3: [[[String!]!]]): [String!]!
  allowExplicitNull(someNullable: String): String!
  searchForUser(input: UserConfig!): User
  entity(id: ID!): UserOrGroup!
  me: User
}

type Pet implements HasName @sourceLoc(fileUri: "tests/Schema.res", startLine: 12, startCol: 0, endLine: 16, endCol: 1) {
  name: String!
  age: Int!
  abbreviatedName: String
}



=== SCHEMA ===

@@warning("-27-32")

open ResGraph__GraphQLJs

let typeUnwrapper: 'src => 'return = %raw(`function typeUnwrapper(src) { if (src == null) return null; if (typeof src === 'object' && src.hasOwnProperty('_0')) return src['_0']; return src;}`)
type inputObjectFieldConverterFn
external makeInputObjectFieldConverterFn: ('a => 'b) => inputObjectFieldConverterFn = "%identity"

let applyConversionToInputObject: (
  'a,
  array<(string, inputObjectFieldConverterFn)>,
) => 'a = %raw(`function applyConversionToInputObject(obj, instructions) {
      if (instructions.length === 0) return obj;
      let newObj = Object.assign({}, obj);
      instructions.forEach(instruction => {
        let value = newObj[instruction[0]];
         newObj[instruction[0]] = instruction[1](value);
      })
      return newObj;
    }`)

let enum_UserStatus = GraphQLEnumType.make({
  name: "UserStatus",
  description: "Indicates what status a user currently has.",
  values: {
    "Online": {
      GraphQLEnumType.value: "Online",
      description: "User is online.",
      deprecationReason: ?None,
    },
    "Offline": {
      GraphQLEnumType.value: "Offline",
      description: "User is offline.",
      deprecationReason: ?None,
    },
    "Idle": {
      GraphQLEnumType.value: "Idle",
      description: "User is idle.",
      deprecationReason: "Use 'Offline' instead.",
    },
  }->makeEnumValues,
})
let i_Node: ref<GraphQLInterfaceType.t> = Obj.magic({"contents": Js.null})
let get_Node = () => i_Node.contents
let i_HasName: ref<GraphQLInterfaceType.t> = Obj.magic({"contents": Js.null})
let get_HasName = () => i_HasName.contents
let t_Mutation: ref<GraphQLObjectType.t> = Obj.magic({"contents": Js.null})
let get_Mutation = () => t_Mutation.contents
let t_User: ref<GraphQLObjectType.t> = Obj.magic({"contents": Js.null})
let get_User = () => t_User.contents
let t_Group: ref<GraphQLObjectType.t> = Obj.magic({"contents": Js.null})
let get_Group = () => t_Group.contents
let t_Query: ref<GraphQLObjectType.t> = Obj.magic({"contents": Js.null})
let get_Query = () => t_Query.contents
let t_Pet: ref<GraphQLObjectType.t> = Obj.magic({"contents": Js.null})
let get_Pet = () => t_Pet.contents
let input_UserConfig: ref<GraphQLInputObjectType.t> = Obj.magic({"contents": Js.null})
let get_UserConfig = () => input_UserConfig.contents
let input_UserConfig_conversionInstructions = []
let input_UserConfigContext: ref<GraphQLInputObjectType.t> = Obj.magic({"contents": Js.null})
let get_UserConfigContext = () => input_UserConfigContext.contents
let input_UserConfigContext_conversionInstructions = []
input_UserConfig_conversionInstructions->Array.pushMany([
  ("name", makeInputObjectFieldConverterFn(v => v->Nullable.toOption)),
  (
    "context",
    makeInputObjectFieldConverterFn(v =>
      switch v->Nullable.toOption {
      | None => None
      | Some(v) =>
        v->applyConversionToInputObject(input_UserConfigContext_conversionInstructions)->Some
      }
    ),
  ),
])
input_UserConfigContext_conversionInstructions->Array.pushMany([
  ("name", makeInputObjectFieldConverterFn(v => v->Nullable.toOption)),
])
let union_UserOrGroup: ref<GraphQLUnionType.t> = Obj.magic({"contents": Js.null})
let get_UserOrGroup = () => union_UserOrGroup.contents

let union_UserOrGroup_resolveType = (v: Schema.userOrGroup) =>
  switch v {
  | User(_) => "User"
  | Group(_) => "Group"
  }

let interface_Node_resolveType = (v: ResGraphSchemaAssets.node_resolver) =>
  switch v {
  | Group(_) => "Group"
  | User(_) => "User"
  }

let interface_HasName_resolveType = (v: ResGraphSchemaAssets.hasName_resolver) =>
  switch v {
  | Pet(_) => "Pet"
  | Group(_) => "Group"
  | User(_) => "User"
  }

i_Node.contents = GraphQLInterfaceType.make({
  name: "Node",
  description: "An object with an ID",
  interfaces: [],
  fields: () =>
    {
      "id": {
        typ: Scalars.id->Scalars.toGraphQLType->nonNull,
        description: "The id of the object.",
        deprecationReason: ?None,
      },
    }->makeFields,
  resolveType: GraphQLInterfaceType.makeResolveInterfaceTypeFn(interface_Node_resolveType),
  astNode: {
    uri: "./src/NodeInterface.res",
    range: {"start": {"line": 2, "character": 0}, "end": {"line": 6, "character": 1}},
  },
})
i_HasName.contents = GraphQLInterfaceType.make({
  name: "HasName",
  description: "An entity with a name.",
  interfaces: [],
  fields: () =>
    {
      "abbreviatedName": {
        typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
      },
      "name": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
      },
    }->makeFields,
  resolveType: GraphQLInterfaceType.makeResolveInterfaceTypeFn(interface_HasName_resolveType),
  astNode: {
    uri: "./tests/HasNameInterface.res",
    range: {"start": {"line": 2, "character": 0}, "end": {"line": 2, "character": 40}},
  },
})
t_Mutation.contents = GraphQLObjectType.make({
  name: "Mutation",
  description: ?None,
  interfaces: [],
  fields: () =>
    {
      "addUser": {
        typ: get_User()->GraphQLObjectType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        args: {"name": {typ: Scalars.string->Scalars.toGraphQLType->nonNull}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.Mutations.addUser(src, ~name=args["name"])
        }),
      },
    }->makeFields,
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 146, "character": 0}, "end": {"line": 146, "character": 18}},
  },
})
t_User.contents = GraphQLObjectType.make({
  name: "User",
  description: "A user in the system.",
  interfaces: [get_Node(), get_HasName()],
  fields: () =>
    {
      "id": {
        typ: Scalars.id->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          NodeInterfaceResolver.id(src)
        }),
      },
      "allNames": {
        typ: GraphQLListType.make(Scalars.string->Scalars.toGraphQLType->nonNull)
        ->GraphQLListType.toGraphQLType
        ->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.UserFields.allNames(src)
        }),
      },
      "currentStatus": {
        typ: enum_UserStatus->GraphQLEnumType.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.UserFields.currentStatus(src)
        }),
      },
      "name": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        args: {"includeFullName": {typ: Scalars.boolean->Scalars.toGraphQLType}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.UserFields.name(src, ~includeFullName=args["includeFullName"]->Nullable.toOption)
        }),
      },
      "id": {
        typ: Scalars.id->Scalars.toGraphQLType->nonNull,
        description: "The id of the object.",
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["id"]
        }),
      },
      "name": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["name"]
        }),
      },
      "age": {
        typ: Scalars.int->Scalars.toGraphQLType->nonNull,
        description: "The age of the user.",
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["age"]
        }),
      },
      "lastAge": {
        typ: Scalars.int->Scalars.toGraphQLType,
        description: "The last age of the user.",
        deprecationReason: "Use 'age' instead.",
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["lastAge"]
        }),
      },
      "abbreviatedName": {
        typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          HasNameInterfaceResolvers.abbreviatedName(src)
        }),
      },
    }->makeFields,
  astNode: {
    uri: "./tests/User.res",
    range: {"start": {"line": 2, "character": 0}, "end": {"line": 9, "character": 1}},
  },
})
t_Group.contents = GraphQLObjectType.make({
  name: "Group",
  description: "A group in the system.",
  interfaces: [get_Node(), get_HasName()],
  fields: () =>
    {
      "id": {
        typ: Scalars.id->Scalars.toGraphQLType->nonNull,
        description: "The id of the object.",
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["id"]
        }),
      },
      "name": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["name"]
        }),
      },
      "abbreviatedName": {
        typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          HasNameInterfaceResolvers.abbreviatedName(src)
        }),
      },
    }->makeFields,
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 4, "character": 0}, "end": {"line": 9, "character": 1}},
  },
})
t_Query.contents = GraphQLObjectType.make({
  name: "Query",
  description: ?None,
  interfaces: [],
  fields: () =>
    {
      "nodes": {
        typ: GraphQLListType.make(get_Node()->GraphQLInterfaceType.toGraphQLType)
        ->GraphQLListType.toGraphQLType
        ->nonNull,
        description: "Fetches objects given their IDs.",
        deprecationReason: ?None,
        args: {
          "ids": {
            typ: GraphQLListType.make(Scalars.id->Scalars.toGraphQLType->nonNull)
            ->GraphQLListType.toGraphQLType
            ->nonNull,
          },
        }->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          NodeInterfaceResolver.nodes(src, ~ids=args["ids"], ~ctx)
        }),
      },
      "node": {
        typ: get_Node()->GraphQLInterfaceType.toGraphQLType,
        description: "Fetches an object given its ID.",
        deprecationReason: ?None,
        args: {"id": {typ: Scalars.id->Scalars.toGraphQLType->nonNull}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          NodeInterfaceResolver.node(src, ~id=args["id"], ~ctx)
        }),
      },
      "hasName": {
        typ: get_HasName()->GraphQLInterfaceType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        args: {"id": {typ: Scalars.id->Scalars.toGraphQLType->nonNull}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          HasNameInterfaceResolvers.hasName(src, ~id=args["id"])
        }),
      },
      "pet": {
        typ: get_Pet()->GraphQLObjectType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.pet(src)
        }),
      },
      "listAsArgs": {
        typ: GraphQLListType.make(Scalars.string->Scalars.toGraphQLType->nonNull)
        ->GraphQLListType.toGraphQLType
        ->nonNull,
        description: ?None,
        deprecationReason: ?None,
        args: {
          "regularList": {
            typ: GraphQLListType.make(Scalars.string->Scalars.toGraphQLType)
            ->GraphQLListType.toGraphQLType
            ->nonNull,
          },
          "optionalList": {
            typ: GraphQLListType.make(
              Scalars.string->Scalars.toGraphQLType->nonNull,
            )->GraphQLListType.toGraphQLType,
          },
          "nullableList": {
            typ: GraphQLListType.make(
              Scalars.string->Scalars.toGraphQLType,
            )->GraphQLListType.toGraphQLType,
          },
          "nullableInnerList": {
            typ: GraphQLListType.make(
              Scalars.string->Scalars.toGraphQLType,
            )->GraphQLListType.toGraphQLType,
          },
          "list1": {
            typ: GraphQLListType.make(
              Scalars.string->Scalars.toGraphQLType,
            )->GraphQLListType.toGraphQLType,
          },
          "list2": {
            typ: GraphQLListType.make(
              GraphQLListType.make(
                Scalars.string->Scalars.toGraphQLType,
              )->GraphQLListType.toGraphQLType,
            )->GraphQLListType.toGraphQLType,
          },
          "list3": {
            typ: GraphQLListType.make(
              GraphQLListType.make(
                GraphQLListType.make(Scalars.string->Scalars.toGraphQLType->nonNull)
                ->GraphQLListType.toGraphQLType
                ->nonNull,
              )->GraphQLListType.toGraphQLType,
            )->GraphQLListType.toGraphQLType,
          },
        }->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.listAsArgs(
            src,
            ~regularList=args["regularList"]->Array.map(v => v->Nullable.toOption),
            ~optionalList=?args["optionalList"]->Nullable.toOption,
            ~nullableList=args["nullableList"]->Nullable.map(v =>
              v->Array.map(v => v->Nullable.toOption)
            ),
            ~nullableInnerList=args["nullableInnerList"]->Nullable.map(v =>
              v->Array.map(v => v->Nullable.toOption)
            ),
            ~list1=switch args["list1"]->Nullable.toOption {
            | None => None
            | Some(v) => v->Array.map(v => v->Nullable.toOption)->Some
            },
            ~list2=switch args["list2"]->Nullable.toOption {
            | None => None
            | Some(v) =>
              v
              ->Array.map(v =>
                switch v->Nullable.toOption {
                | None => None
                | Some(v) => v->Array.map(v => v->Nullable.toOption)->Some
                }
              )
              ->Some
            },
            ~list3=switch args["list3"]->Nullable.toOption {
            | None => None
            | Some(v) => v->Array.map(v => v->Nullable.toOption)->Some
            },
          )
        }),
      },
      "allowExplicitNull": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        args: {"someNullable": {typ: Scalars.string->Scalars.toGraphQLType}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.allowExplicitNull(src, ~someNullable=args["someNullable"])
        }),
      },
      "searchForUser": {
        typ: get_User()->GraphQLObjectType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        args: {
          "input": {typ: get_UserConfig()->GraphQLInputObjectType.toGraphQLType->nonNull},
        }->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.searchForUser(
            src,
            ~input=args["input"]->applyConversionToInputObject(
              input_UserConfig_conversionInstructions,
            ),
          )
        }),
      },
      "entity": {
        typ: get_UserOrGroup()->GraphQLUnionType.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        args: {"id": {typ: Scalars.id->Scalars.toGraphQLType->nonNull}}->makeArgs,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.entity(src, ~id=args["id"], ~ctx)
        }),
      },
      "me": {
        typ: get_User()->GraphQLObjectType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          Schema.QueryFields.me(src, ~ctx)
        }),
      },
    }->makeFields,
  astNode: {
    uri: "./tests/Query.res",
    range: {"start": {"line": 1, "character": 0}, "end": {"line": 1, "character": 15}},
  },
})
t_Pet.contents = GraphQLObjectType.make({
  name: "Pet",
  description: ?None,
  interfaces: [get_HasName()],
  fields: () =>
    {
      "name": {
        typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["name"]
        }),
      },
      "age": {
        typ: Scalars.int->Scalars.toGraphQLType->nonNull,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, _args, _ctx) => {
          let src = typeUnwrapper(src)
          src["age"]
        }),
      },
      "abbreviatedName": {
        typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
        resolve: makeResolveFn((src, args, ctx) => {
          let src = typeUnwrapper(src)
          HasNameInterfaceResolvers.abbreviatedName(src)
        }),
      },
    }->makeFields,
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 12, "character": 0}, "end": {"line": 16, "character": 1}},
  },
})
input_UserConfig.contents = GraphQLInputObjectType.make({
  name: "UserConfig",
  description: "Configuration for searching for a user.",
  fields: () =>
    {
      "id": {
        GraphQLInputObjectType.typ: Scalars.string->Scalars.toGraphQLType->nonNull,
        description: "The ID of a user to search for.",
        deprecationReason: ?None,
      },
      "name": {
        GraphQLInputObjectType.typ: Scalars.string->Scalars.toGraphQLType,
        description: "The name of the user to search for.",
        deprecationReason: "This is going away",
      },
      "context": {
        GraphQLInputObjectType.typ: get_UserConfigContext()->GraphQLInputObjectType.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
      },
    }->makeFields,
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 63, "character": 0}, "end": {"line": 69, "character": 1}},
  },
})
input_UserConfigContext.contents = GraphQLInputObjectType.make({
  name: "UserConfigContext",
  description: "Additional for searching for a user.",
  fields: () =>
    {
      "groupId": {
        GraphQLInputObjectType.typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
      },
      "name": {
        GraphQLInputObjectType.typ: Scalars.string->Scalars.toGraphQLType,
        description: ?None,
        deprecationReason: ?None,
      },
    }->makeFields,
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 57, "character": 0}, "end": {"line": 60, "character": 1}},
  },
})
union_UserOrGroup.contents = GraphQLUnionType.make({
  name: "UserOrGroup",
  description: "A user or a group.",
  types: () => [get_User(), get_Group()],
  resolveType: GraphQLUnionType.makeResolveUnionTypeFn(union_UserOrGroup_resolveType),
  astNode: {
    uri: "tests/Schema.res",
    range: {"start": {"line": 20, "character": 0}, "end": {"line": 20, "character": 96}},
  },
})

let schema = GraphQLSchemaType.make({"query": get_Query(), "mutation": get_Mutation()})


